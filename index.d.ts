/** Declaration file generated by dts-gen */
import * as http from 'http'
import * as net from 'net'

declare namespace EngineIO {

    class _Events<T extends {[k:string]:any[]}> {
        addListener : <K extends keyof T>(type : K,cb : (e? : T[K][0],f? : T[K][1]) => void) => void
        on : <K extends keyof T>(type : K,cb : (e? : T[K][0],f? : T[K][1]) => void) => void
        off : <K extends keyof T>(type : K,cb : (e? : T[K][0],f? : T[K][1]) => void) => void
        once : <K extends keyof T>(type : K,cb : (e? : T[K][0],f? : T[K][1]) => void) => void
        prependListener : <K extends keyof T>(type : K,cb : (e? : T[K][0],f? : T[K][1]) => void) => void
        prependOnceListener : <K extends keyof T>(type : K,cb : (e? : T[K][0],f? : T[K][1]) => void) => void
        removeListener : <K extends keyof T>(type : K,cb : (e? : T[K][0],f? : T[K][1]) => void) => void

        removeAllListeners(event?: keyof T): this;
        setMaxListeners(n: number): this;
        getMaxListeners(): number;
        listeners(event: keyof T): Function[];
        emit(event: keyof T, ...args: any[]): boolean;
        eventNames(): (keyof T)[];
        listenerCount(type: keyof T): number;
    }

    interface ServerOption{
        
        /**how many ms without a pong packet to consider the connection closed (60000) */
        pingTimeout?: number
        
        /**how many ms before sending a new ping packet (25000) */
        pingInterval?: number
        
        /**how many ms before an uncompleted transport upgrade is cancelled (10000) */
        upgradeTimeout?: number
        
        /**how many bytes or characters a message can be, before closing the session (to avoid DoS). Default value is 10E7. */
        maxHttpBufferSize?: number
        
        /**A function that receives a given handshake or upgrade request as its first parameter, and can decide whether to continue or not.
         * The second argument is a function that needs to be called with the decided information: fn(err, success), 
         * where success is a boolean value where false means that the request is rejected, and err is an error code.*/
        allowRequest?: (err : any,success : any) => void
        
        /**transports to allow connections to (['polling', 'websocket']) */
        transports?: string[]
        
        /**whether to allow transport upgrades (true) */
        allowUpgrades?: boolean
        
        /**parameters of the WebSocket permessage-deflate extension (see ws module api docs). Set to false to disable. (true) */
        perMessageDeflate?: {threshold : number} | boolean
        
        /**parameters of the http compression for the polling transports (see zlib api docs). Set to false to disable. (true) */
        httpCompression?: {threshold : number} | Boolean
        
        /**name of the HTTP cookie that contains the client sid to send as part of handshake response headers. Set to false to not send one. (io) */
        cookie?: string | false
        
        /**path of the above cookie option. 
         * If false, no path will be sent, which means browsers will only send the cookie on the engine.io attached path (/engine.io). 
         * Set false to not save io cookie on all requests. (/) */
        cookiePath?: string | false
        
        /**If true HttpOnly io cookie cannot be accessed by client-side APIs, such as JavaScript. 
         * (true) This option has no effect if cookie or cookiePath is set to false. */
        cookieHttpOnly?: boolean
        
        /** what WebSocket server implementation to use. 
         * Specified module must conform to the ws interface (see ws module api docs). 
         * Default value is ws. An alternative c++ addon is also available by installing uws module. */
        wsEngine?: string
        
        /**an optional packet which will be concatenated to the handshake packet emitted by Engine.IO. */
        initialPacket?: any
    } 

    interface ServerAttachOption {
        /** name of the path to capture (/engine.io).*/
        path : String,
        /** destroy unhandled upgrade requests (true)*/
        destroyUpgrade : Boolean,
        /** milliseconds after which unhandled requests are ended (1000)*/
        destroyUpgradeTimeout : Number,
        /** whether to let engine.io handle the OPTIONS requests. You can also pass a custom function to handle the requests (true)*/
        handlePreflightRequest : Boolean|Function,
    }

    /**
     * The main server/manager. Inherits from EventEmitter.
     */
    class Server extends _Events<{'connection' : [Socket]}>{
        constructor(opts?: ServerOption);

        /** hash of connected clients by id. */
        clients : Object

        /**number of connected clients. */
        clientsCount : number

        /** Closes all clients*/
        close(): Server;

        /** Called internally when a Engine request is intercepted.*/
        handleRequest(req: Request, res: Response): Server;

        /**
         * Called internally when a Engine ws upgrade is intercepted.
         * @param req : a node request object
         * @param socket : TCP socket for the request
         * @param upgradeHead : legacy tail bytes
         */    
        handleUpgrade(req: Request, socket: net.Socket , upgradeHead: Buffer): Server;

        /**
         ** Attach this Server instance to an http.Server
         ** Captures upgrade requests for a http.Server. In other words, makes a regular http.Server WebSocket-compatible.
         * @param server {http.Server} server to attach to.
         * @param options {ServerAttachOption}  optional, options object
        */
        attach(server: http.Server, options?: ServerAttachOption): any;

        /**
         ** Generate a socket id. 
         ** Overwrite this method to generate your custom socket id.
         * @param req {Request} http.IncomingMessage: a node request object
         */
        generateId(req: Request): number;

    }

    /**
     * A representation of a client. Inherits from EventEmitter.
     */
    class Socket extends _Events<{
        close : [string,Object]
        message : [string | Buffer]
        error : [Error]
        flush : [ArrayBuffer]
        drain : [void]
        packet : [string,any]
        packetCreate : [string,any]
    }> {
        
        constructor(id?: any, server?: any, transport?: any, req?: any);

        /**unique identifier*/
        id : String 
        /**engine parent reference*/
        server : Server 
        /**IncomingMessage): request that originated the Socket*/
        request : Request 
        /**whether the transport has been upgraded*/
        upgraded : Boolean 
        /**opening|open|closing|closed*/
        readyState : String 
        /**transport reference*/
        transport : Transport 

        /**
         * Sends a message, performing message = toString(arguments[0]) unless sending binary data, which is sent as is.
         * @param data  a string or any object implementing toString(), with outgoing data, or a Buffer or ArrayBuffer with binary data. Also any ArrayBufferView can be sent as is.
         * @param options optional, options object
         * @param callback optional, a callback executed when the message gets flushed out by the transport
         */
        send(data: String | Buffer | ArrayBuffer | ArrayBufferView, options?: {compress : boolean}, callback?: Function): Socket;

        /**
         * Disconnects the client
         */
        close(): Socket;

    }


    class Transport {  }


    function listen(port: number, options? : any, fn?: (...a : any[]) => void): Server;
    
    function attach(server: http.Server, options?: any): Server;

}

declare function EngineIO(server?: http.Server): EngineIO.Server;


export = EngineIO
